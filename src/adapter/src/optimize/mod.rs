// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

//! Optimizer interface to the adapter and coordinator code.
//!
//! The goal of this create is to abstract optimizer specifics behind a
//! high-level interface that is ready to be consumed by the adapter /
//! coordinator code in a future-proof way (that is, the API is taking the
//! upcoming evolution of these components into account).
//!
//! The contents of this crate should have minimal dependencies to the rest of
//! the coordinator code so we can pull them out as a separate crate in the
//! future without too much effort.
//!
//! General refactoring guidelines:
//!
//! - Move HIR ⇒ MIR lowering to the sequence_ methods. Benetfits:
//!   - We can piggy-back on a single Optimizer instance.
//!   - All optimization stages are happening in the same place.
//!   - Necesssary context is available (for example feature flags for pre-MIR
//!     stages).
//!
//! - Optimizer takes control over DataflowDescription construction.
//!   - Methods that at the moment are part of DataflowBuilder can become
//!     private methods on the optimizer.
//!   - Which one is used will depend on some notion of context that reflects
//!     what type of statement we are optimizing:
//!     - MaterializedView
//!     - Select
//!     - Index
//!     - Subscribe
//!
//! - What other type of context do we have?
//!   - Across optimization runs?
//!     - Immutable
//!     - Mutable
//!   - Probably we don't want anything from the aobve
//!     - Rather we can benefit form cheap optimizer
//!     - Optimization will not happen in the coordinator
//!     - Optimizer instances should be cheap enough so you can make them once
//!       per connection
//!     - Planning and optimization will run per cluster (there will be a
//!       frontend component per cluster)
//!   - For a single optimization run
//!     - Immutable
//!       - Feature flags
//!       - &dyn IndexOracle (backed by CatalogState snapshot)
//!       - &dyn ExprHumanizer (backed by CatalogState snapshot)
//!       - &dyn StatisticsOracle (produced by &StorageController)
//!         - In platform V2, we can piggy-back somewhat stale connections over
//!           some heartbeat
//!     - Mutable
//!       - Metrics
//!       - Possibly context for plan tracing
//!       - List of notices generated by transforms
//!         - "I could have used this index"
//!
//! - User-facing Optimizer API changes:
//!   - Ideally, the API shouldbe just `optimize(input: T, ctx: &mut C1): U`
//!     where `T` is input type (really `HirRelationExpr` always) `U` depends on
//!     the optimization context:
//!       - The `MirRelationExpr` for view optimization
//!       - A `DataflowDescription<Plan>` for materialized view, index, and
//!         subscribe
//!       - Either `DataflowDescription<Plan>` or `FastPathPlan` for select It
//!   is hard to refactor to the state where one `optimize` method is sufficient
//!   in one PR. Better: introduce an interface with multiple methods that
//!   reflect the different stages
//!   - `hir_to_mir`
//!   - `mir_local`
//!   - `mir_global` (in a SELECT query we need to do the final replacement )
//!   - `mir_to_lir` (including LIR ⇒ LIR suffix) (substitute mz_now() with the
//!   real timestamp) We need to make sure that no changes can happen to the
//!   objects produced after every phase by other code.
//!   - Results of intermediate stages are black box newtype objects
//!   - Only the final type can be converted back into something that needs to
//!     be stored in the catalog / sent to the ComputeController.
//!
//! Next steps:
//! - Integrate these notes into the optimizer interface design doc
//! - Propoes an interface based on these notes in the design doc (stub with
//!   unimplemented! methods)
//! - Get sign-off
//! - Implement the interface

mod materialized_view;
mod select;
mod view;

// Re-export optimzier structs
pub use materialized_view::OptimizeMaterializedView;
pub use select::OptimizeSelect;
pub use view::OptimizeView;

use mz_sql::plan::PlanError;
use mz_transform::TransformError;

use crate::AdapterError;

trait Optimize<'ctx, From> {
    type To: 'ctx;

    /// Execute the optimization stage, transforming the input plan of type
    /// `From` to an output plan of type [`Optimize::To`].
    fn optimize<'a: 'ctx>(&'a mut self, plan: From) -> Result<Self::To, OptimizerError>;

    /// Execute the optimization stage and panic if an error occurs.
    ///
    /// See [`Optimize::optimize`].
    fn must_optimize<'a: 'ctx>(&'a mut self, expr: From) -> Self::To {
        match self.optimize(expr) {
            Ok(ok) => ok,
            Err(err) => panic!("must_optimize call failed: {err}"),
        }
    }
}

#[derive(Debug, thiserror::Error)]
pub enum OptimizerError {
    #[error("{0}")]
    AdapterError(#[from] AdapterError),
    #[error("{0}")]
    PlanError(#[from] PlanError),
    #[error("error: {0}")]
    TransformError(#[from] TransformError),
    #[error("error: {0}")]
    Internal(String),
}
