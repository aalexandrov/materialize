// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the LICENSE file at the
// root of this repository, or online at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::path::Path;
use std::path::PathBuf;
use std::{env, fs};

use anyhow::{anyhow, Context, Result};
use syn::spanned::Spanned;
use syn::{DeriveInput, Item};

const AST_DEFS_MOD: &str = "src/ast/defs.rs";

fn main() -> Result<()> {
    let out_dir = PathBuf::from(env::var_os("OUT_DIR").context("Cannot read OUT_DIR env var")?);

    // Generate AST visitors.
    {
        let mut items = mz_walkabout::parse_mod(AST_DEFS_MOD)?;
        collect_macros(AST_DEFS_MOD, &mut items)?;
        let ir = mz_walkabout::analyze(&items)?;
        let fold = mz_walkabout::gen_fold(&ir);
        let visit = mz_walkabout::gen_visit(&ir);
        let visit_mut = mz_walkabout::gen_visit_mut(&ir);
        fs::write(out_dir.join("fold.rs"), fold)?;
        fs::write(out_dir.join("visit.rs"), visit)?;
        fs::write(out_dir.join("visit_mut.rs"), visit_mut)?;
    }

    Ok(())
}

/// Extend the set of items identified by the crate-agnosic pass (the
/// [`mz_walkabout::parse_mod`] call) with items corresponding to simulated
/// expanded macros specific to this crate.
///
/// We currently support correct waklabout structures generation for AST items
/// defined by the following macro calls:
///
/// - `impl_simple_options!(...)` - handled by [`expand_impl_simple_options`].
fn collect_macros<P>(path: P, out: &mut Vec<DeriveInput>) -> Result<()>
where
    P: AsRef<Path>,
{
    let path = path.as_ref();
    let dir = path.parent().expect("missing parent directory");
    let stem = path
        .file_stem()
        .expect("missing file stem")
        .to_str()
        .expect("file stem is not valid UTF-8");

    let src =
        fs::read_to_string(path).with_context(|| format!("Failed to read {}", path.display()))?;
    let file =
        syn::parse_file(&src).with_context(|| format!("Failed to parse {}", path.display()))?;

    for item in file.items {
        match item {
            Item::Mod(item) if item.content.is_none() => {
                let path = match stem {
                    "mod" | "lib" => dir.join(format!("{}.rs", item.ident)),
                    _ => dir.join(format!("{}/{}.rs", stem, item.ident)),
                };
                collect_macros(path, out)?;
            }
            Item::Macro(item) => {
                for derive_input in expand_impl_simple_options(item)? {
                    out.push(derive_input)
                }
            }
            _ => (),
        }
    }
    Ok(())
}

/// Because `{MACRO_NAME}` generates some structs that should be
/// considered part of the collected items, we need to manually derive the
/// inputs that the macro expansion is going to produce here.
///
/// The method receives a [`syn::ItemMacro`] item. If the item corresponds to a
///
/// ```ignore
/// impl_simple_options!($name {
///    $option1,
///    $option2,
/// });
/// ```
/// call, the result will be a vector consisting of the [`syn::DeriveInput`]
/// items that will be generated by the macro expansion. For all other
/// [`syn::ItemMacro`] items, the result is going to be the empty vector.
///
/// The function will error if the macro invocation does not follow the expected
/// format (which should never happen as long as the implementation below is
/// kept in sync with the syntax supported by the `{MACRO_NAME}` macro
/// rules).
fn expand_impl_simple_options(item: syn::ItemMacro) -> Result<Vec<syn::DeriveInput>> {
    use proc_macro2::{Delimiter, TokenTree};

    const MACRO_NAME: &str = "impl_simple_options";

    let item_span = item.span();

    // Macro::path must match the following fragment:
    // ```
    // Path {
    //     segments: [
    //         PathSegment {
    //             ident: Ident {
    //                 sym: MACRO_NAME,
    //                 ..
    //             },
    //             ..
    //         },
    //     ],
    //     ..
    // }
    // ```
    if item.mac.path.segments.len() != 1 {
        return Ok(Vec::new());
    }
    let Some(path_segment) = item.mac.path.segments.first() else {
        return Ok(Vec::new());
    };
    if path_segment.ident != MACRO_NAME {
        return Ok(Vec::new());
    }

    // Macro::tokens must match the following TokenStream:
    // ```
    // $name {
    //    $option1,
    //    $option2,
    // }
    // ```
    let mut tokens = item.mac.tokens.into_iter();
    let Some(TokenTree::Ident(name)) = tokens.next() else {
        return Err(anyhow!(
            "unsupported macro parameter format in `{MACRO_NAME}`: \
             expected $name identifier"
        ));
    };
    let Some(TokenTree::Group(options_group)) = tokens.next() else {
        return Err(anyhow!(
            "unsupported macro parameter format in `{MACRO_NAME}`: \
             expected options group"
        ));
    };
    if options_group.delimiter() != Delimiter::Brace {
        return Err(anyhow!(
            "unsupported macro parameter format in `{MACRO_NAME}`: \
             expected options group delimiter"
        ));
    }
    let mut options = Vec::<syn::Ident>::with_capacity(10);
    for (token_no, token) in options_group.stream().into_iter().enumerate() {
        match (token_no % 2, token) {
            (0, TokenTree::Ident(ident)) if ident.to_string().is_ascii() => {
                options.push(ident) // Odd tokens should be ASCII idents representing options.
            }
            (1, TokenTree::Punct(punct)) if punct.as_char() == ',' => {
                // Even tokens should be the `,` separator.
            }
            _ => {
                return Err(anyhow!(
                    "unsupported macro parameter format in `{MACRO_NAME}`: \
                     unexpected token in options group"
                ));
            }
        }
    }

    // Compute the derived syntax parts used by the expanded macro.
    let enum_name = syn::Ident::new(format!("{name}Name").as_str(), name.span());
    let enum_variants = options.into_iter().map(camel_case);

    // The DeriveInput synthesized here should coincide with the one that is
    // actually expanded by the macro.
    let Ok(option_name_enum) = syn::parse2::<syn::DeriveInput>(quote::quote_spanned! {item_span=>
        #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum #enum_name {
            #(#enum_variants),*
        }
    }) else {
        return Err(anyhow!(format!(
            "internal error in `expand_{MACRO_NAME}`: \
             while constructing {enum_name} enum"
        )));
    };

    // The DeriveInput synthesized here should coincide with the one that is
    // actually expanded by the macro.
    let Ok(struct_input) = syn::parse2::<syn::DeriveInput>(quote::quote_spanned! {item_span=>
        #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub struct #name<T: AstInfo> {
            pub name: #enum_name,
            pub value: Option<WithOptionValue<T>>,
        }
    }) else {
        return Err(anyhow!(format!(
            "internal error in `expand_{MACRO_NAME}`: \
             while constructing {name} struct"
        )));
    };

    Ok(Vec::from([option_name_enum, struct_input]))
}

/// Convert an identifier from snake case to camel case.
///
/// The source code is taken from the `paste` crate[^source], which used in the
/// implementation of the `impl_simple_options` macro.
///
/// [^source]: <https://github.com/dtolnay/paste/blob/ed844dc6fe755bcee881bd93cdff5a77038aa49b/src/segment.rs#L195-L215>
fn camel_case(ident: syn::Ident) -> syn::Ident {
    let mut camel_case = String::new();
    let mut prev = '_';
    for ch in ident.to_string().chars() {
        if ch != '_' {
            if prev == '_' {
                for chu in ch.to_uppercase() {
                    camel_case.push(chu);
                }
            } else if prev.is_uppercase() {
                for chl in ch.to_lowercase() {
                    camel_case.push(chl);
                }
            } else {
                camel_case.push(ch);
            }
        }
        prev = ch;
    }
    syn::Ident::new(camel_case.as_str(), ident.span())
}
