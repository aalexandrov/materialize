# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

# Regression test for #19273 and #19283.

statement ok
CREATE SOURCE tpch
            FROM LOAD GENERATOR TPCH (SCALE FACTOR 0.00001)
            FOR ALL TABLES
            WITH (SIZE = '1');

statement ok
CREATE SOURCE auction
            FROM LOAD GENERATOR AUCTION (SCALE FACTOR 0.01)
            FOR ALL TABLES
            WITH (SIZE = '1');

statement ok
CREATE SOURCE counter
            FROM LOAD GENERATOR COUNTER (SCALE FACTOR 0.0001)
            WITH (SIZE = '1');

statement ok
CREATE TABLE t (a int2, b int4, c int8, d uint2, e uint4, f uint8, g text);

statement ok
INSERT INTO t VALUES
  (1, 2, 3, 4, 5, 6, '7'),
  (3, 4, 5, 6, 7, 8, '9'),
  (5, 6, 7, 8, 9, 10, '11'),
  (7, 8, 9, 10, 11, 12, '13'),
  (9, 10, 11, 12, 13, 14, '15'),
  (11, 12, 13, 14, 15, 16, '17'),
  (13, 14, 15, 16, 17, 18, '19'),
  (15, 16, 17, 18, 19, 20, '21');

statement ok
CREATE MATERIALIZED VIEW mv AS SELECT a + b AS col1, c + d AS col2, e + f AS col3, g AS col4 FROM t;

statement ok
CREATE MATERIALIZED VIEW mv2 AS SELECT count(*) FROM mv;

statement ok
CREATE DEFAULT INDEX ON mv;

query T multiline
EXPLAIN DECORRELATED PLAN AS TEXT FOR SELECT
  subq_4."c0" as c0,
  (pg_catalog.mod(
      CAST(pg_catalog.mod(
        CAST(pg_catalog.mod(
          CAST(null::uint2 as uint2),
          CAST(cast(nullif(null::uint2,
            null::uint2) as uint2) as uint2)) as uint2),
        CAST(case when (cast(null as aclitem)) = (cast(null as aclitem)) then null::uint2 else null::uint2 end
           as uint2)) as uint2),
      CAST(0::uint2 as uint2))) + (((pg_catalog.mod(
          CAST(case when true then null::uint2 else null::uint2 end
             as uint2),
          CAST(null::uint2 as uint2))) % (pg_catalog.mod(
          CAST((null::uint2) & (0::uint2) as uint2),
          CAST(
            pg_catalog.max(
              CAST(65535::uint2 as uint2)) over (partition by subq_4."c0" order by subq_4."c0") as uint2)))) << (((pg_catalog.mod(
            CAST(null::uint4 as uint4),
            CAST(10::uint4 as uint4))) | (null::uint4)) # (pg_catalog.mod(
          CAST(pg_catalog.mod(
            CAST(0::uint4 as uint4),
            CAST(10::uint4 as uint4)) as uint4),
          CAST(0::uint4 as uint4))))) as c1
FROM
  (SELECT
        pg_catalog.jsonb_build_array() as c0
      FROM
        (SELECT
              subq_2."c0" as c0,
              subq_2."c2" as c1,
              subq_2."c3" as c2,
              subq_2."c4" as c3,
              subq_2."c3" as c4,
              subq_2."c4" as c5,
              subq_2."c4" as c6,
              subq_2."c1" as c7,
              subq_2."c0" as c8,
              subq_2."c4" as c9,
              subq_2."c3" as c10,
              33 as c11,
              66 as c12,
              subq_2."c4" as c13,
              subq_2."c4" as c14
            FROM
              (SELECT
                    subq_0."c0" as c0,
                    subq_0."c1" as c1,
                    subq_0."c2" as c2,
                    subq_1."c16" as c3,
                    subq_1."c2" as c4,
                    subq_0."c1" as c5
                  FROM
                    (SELECT
                          68 as c0,
                          80 as c1,
                          4 as c2
                        FROM
                          "mz_internal"."mz_cluster_replica_history" as ref_1
                        where (2::bpchar) < (null::bpchar)
                        limit 93) as subq_0,
                    LATERAL (SELECT
                          subq_0."c0" as c0,
                          5 as c1,
                          subq_0."c1" as c2,
                          subq_0."c0" as c3,
                          1 as c4,
                          subq_0."c2" as c5,
                          subq_0."c0" as c6,
                          subq_0."c1" as c7,
                          subq_0."c1" as c8,
                          subq_0."c0" as c9,
                          subq_0."c2" as c10,
                          subq_0."c0" as c11,
                          subq_0."c2" as c12,
                          subq_0."c1" as c13,
                          subq_0."c0" as c14,
                          subq_0."c1" as c15,
                          subq_0."c2" as c16,
                          subq_0."c1" as c17,
                          subq_0."c2" as c18,
                          subq_0."c2" as c19,
                          subq_0."c1" as c20,
                          subq_0."c1" as c21,
                          66 as c22,
                          subq_0."c0" as c23,
                          subq_0."c2" as c24,
                          subq_0."c0" as c25,
                          subq_0."c2" as c26,
                          subq_0."c2" as c27,
                          63 as c28,
                          subq_0."c1" as c29,
                          subq_0."c2" as c30
                        FROM
                          "mz_internal"."mz_activity_log" as ref_2
                        where (1::bpchar) < (null::bpchar)) as subq_1
                  where (true)
                    and (subq_0."c2" is not NULL)) as subq_2
            WHERE true) as subq_3
      where (2::bpchar) ~* ((subq_3."c5") || (pg_catalog.current_database()))) as subq_4
where (((true)
      and ((case when (10::mz_timestamp) = (2::mz_timestamp) then mz_catalog.mz_uptime() else mz_catalog.mz_uptime() end
          ) = ((mz_catalog.mz_uptime()) + (pg_catalog.justify_interval(
            CAST(INTERVAL '2147483647 MONTHS' as interval))))))
    and ((case when (case when (row(1)) < (row(1)) then null::bpchar else null::bpchar end
            ) !~~* (1::text) then pg_catalog.current_user() else pg_catalog.current_user() end
        ) !~ ((pg_catalog.lpad(
          CAST(pg_catalog.current_database() as text),
          CAST((97) << (52) as int4))) || (subq_4."c0"))))
  or ((null::bpchar) >= (case when subq_4."c0" is NULL then case when (pg_catalog.mod(
            CAST(null::uint4 as uint4),
            CAST(10::uint4 as uint4))) = (cast(coalesce(null::uint4,
            4294967295::uint4) as uint4)) then case when ((((DATE '2007-02-01') > (DATE '2007-02-01'))
                or ((null::numeric) <= (2::numeric)))
              or (((TIME '01:23:45') >= (TIME '01:23:45'))
                or (false)))
            or ((null::bpchar) ~~* (null::text)) then cast(0 as bpchar) else cast(0 as bpchar) end
           else case when ((((DATE '2007-02-01') > (DATE '2007-02-01'))
                or ((null::numeric) <= (2::numeric)))
              or (((TIME '01:23:45') >= (TIME '01:23:45'))
                or (false)))
            or ((null::bpchar) ~~* (null::text)) then cast(0 as bpchar) else cast(0 as bpchar) end
           end
         else case when (pg_catalog.mod(
            CAST(null::uint4 as uint4),
            CAST(10::uint4 as uint4))) = (cast(coalesce(null::uint4,
            4294967295::uint4) as uint4)) then case when ((((DATE '2007-02-01') > (DATE '2007-02-01'))
                or ((null::numeric) <= (2::numeric)))
              or (((TIME '01:23:45') >= (TIME '01:23:45'))
                or (false)))
            or ((null::bpchar) ~~* (null::text)) then cast(0 as bpchar) else cast(0 as bpchar) end
           else case when ((((DATE '2007-02-01') > (DATE '2007-02-01'))
                or ((null::numeric) <= (2::numeric)))
              or (((TIME '01:23:45') >= (TIME '01:23:45'))
                or (false)))
            or ((null::bpchar) ~~* (null::text)) then cast(0 as bpchar) else cast(0 as bpchar) end
           end
         end
      ));
----
Return
  Project (#0, #2)
    Map (((((null % case when (null = null) then null else null end) % case when (null = null) then null else null end) % integer_to_uint2(0)) + (((case when true then null else null end % null) % ((null & integer_to_uint2(0)) % #1)) << (((null % integer_to_uint4(10)) | null) # ((integer_to_uint4(0) % integer_to_uint4(10)) % integer_to_uint4(0))))))
      Project (#0, #2)
        Map (#1)
          Project (#3, #4)
            Map (record_get[0](record_get[1](#2)), record_get[0](#2))
              FlatMap unnest_list(#1)
                Reduce group_by=[#0] aggregates=[window_agg[max order_by=[#0 asc nulls_last]](row(row(row(#0), integer_to_uint2(65535)), #0))]
                  Filter (((true AND (case when (integer_to_mz_timestamp(10) = integer_to_mz_timestamp(2)) then mz_uptime() else mz_uptime() end = (mz_uptime() + justify_interval(178956970 years 7 months)))) AND NOT((case when NOT((padchar(case when (row(1) < row(1)) then null else null end) ilike integer_to_text(1))) then current_user() else current_user() end ~ (lpad(current_database(), (97 << 52)) || jsonb_to_text(#0))))) OR (null >= case when (#0) IS NULL then case when ((null % integer_to_uint4(10)) = coalesce(null, bigint_to_uint4(4294967295))) then case when ((((text_to_date("2007-02-01") > text_to_date("2007-02-01")) OR (null <= integer_to_numeric(2))) OR ((text_to_time("01:23:45") >= text_to_time("01:23:45")) OR false)) OR (padchar(null) ilike null)) then text_to_char(integer_to_text(0)) else text_to_char(integer_to_text(0)) end else case when ((((text_to_date("2007-02-01") > text_to_date("2007-02-01")) OR (null <= integer_to_numeric(2))) OR ((text_to_time("01:23:45") >= text_to_time("01:23:45")) OR false)) OR (padchar(null) ilike null)) then text_to_char(integer_to_text(0)) else text_to_char(integer_to_text(0)) end end else case when ((null % integer_to_uint4(10)) = coalesce(null, bigint_to_uint4(4294967295))) then case when ((((text_to_date("2007-02-01") > text_to_date("2007-02-01")) OR (null <= integer_to_numeric(2))) OR ((text_to_time("01:23:45") >= text_to_time("01:23:45")) OR false)) OR (padchar(null) ilike null)) then text_to_char(integer_to_text(0)) else text_to_char(integer_to_text(0)) end else case when ((((text_to_date("2007-02-01") > text_to_date("2007-02-01")) OR (null <= integer_to_numeric(2))) OR ((text_to_time("01:23:45") >= text_to_time("01:23:45")) OR false)) OR (padchar(null) ilike null)) then text_to_char(integer_to_text(0)) else text_to_char(integer_to_text(0)) end end end))
                    Project (#15)
                      Map (jsonb_build_array())
                        Filter (padchar(text_to_char(integer_to_text(2))) ~* (integer_to_text(#5) || current_database()))
                          Project (#0, #2..=#4, #3, #4, #4, #1, #0, #4, #3, #6, #7, #4, #4)
                            Map (33, 66)
                              Filter true
                                Project (#0..=#2, #19, #5, #1)
                                  Filter (true AND (#2) IS NOT NULL)
                                    Filter true
                                      Project (#0..=#2, #6..=#36)
                                        Join on=(#0 = #3 AND #1 = #4 AND #2 = #5)
                                          Get l0
                                          Project (#0..=#2, #25..=#27, #25, #28, #29, #25, #27, #27, #25, #29, #25, #29, #27, #25, #27, #29, #27, #29, #29, #27, #27, #30, #25, #29, #25, #29, #29, #31, #27, #29)
                                            Map (#0, 5, #1, 1, #2, 66, 63)
                                              Filter (text_to_char(integer_to_text(1)) < null)
                                                CrossJoin
                                                  Distinct project=[#0..=#2]
                                                    Get l0
                                                  Get mz_internal.mz_activity_log
With
  cte l0 =
    Project (#7..=#9)
      TopK limit=93
        Project (#0..=#9)
          Map (68, 80, 4)
            Filter (text_to_char(integer_to_text(2)) < null)
              CrossJoin
                Constant
                  - ()
                Get mz_internal.mz_cluster_replica_history

EOF
